Require Import VST.floyd.proofauto.
Require Import VST.floyd.Funspec_old_Notation.
Require Import DL.verif.dlinklist.

Instance CompSpecs : compspecs. make_compspecs prog. Defined.
Definition Vprog : varspecs. mk_varspecs prog. Defined.

Local Open Scope logic.

(***********************************************************************
I.Auxiliary tactics
***********************************************************************)

(* solve field_compatible _ [] nullval *)
Ltac sfcn :=
  match goal with
  | H : field_compatible _ [] nullval |- _  => destruct H; inversion H
  | _                                       => idtac
  end.

(* solve the subgoal generated by freeN *)
Ltac solve_free := 
  entailer!; rewrite memory_block_data_at_ by auto; cancel.

(* simplify length *)
Ltac simpl_length :=
  simpl Datatypes.length in *;
  simpl Nat.sub in *;
  rewrite Nat.sub_0_r in *.
  
(***********************************************************************
II.Functional Specification and Lemmas
***********************************************************************)

(** Split the list into three parts: 
    the first n elements, the (n+1)th element, and the other elements. *)
Fixpoint list_nth_out (l : list Z) (n : nat) : (list Z) * (option Z) * (list Z) := 
  match n with 
  | O     =>
    match l with
    | x :: l'   => (nil, Some x, l')
    | nil       => (nil, None, nil)
    end
  | S n'  =>
    match l with
    | x :: l'   => let '(l1, y, l2) := list_nth_out l' n' in (x :: l1, y, l2)
    | nil       => list_nth_out nil n'
    end
  end.

(** Take the prefix with length n of l. *)
Fixpoint list_prefix (l : list Z) (n : nat) : list Z :=
  match n with
  | O     => nil
  | S n'  => 
    match l with
    | x :: l'   => x :: (list_prefix l' n')
    | nil       => list_prefix nil n'
    end
  end.

(** Choose the (n+1)th element of l. *)
Fixpoint list_index (l : list Z) (n : nat) : option Z :=
  match l with
  | x :: l'   => 
    match n with
    | O       => Some x
    | S n'    => list_index l' n'
    end
  | nil       => None
  end.

(* auxiliary lemmas *)
Lemma nil_prefix_nil : forall n, list_prefix nil n = nil.
Proof.
  intros. induction n.
  - reflexivity.
  - simpl. exact IHn.
Qed.

Lemma list_decomposition : forall l n, exists (suf : list Z), 
  l = (list_prefix l n) ++ suf.  (* 2: list=prefix+surfix *)
Proof.
  intros l. induction l.
  - intros. exists nil. simpl. rewrite nil_prefix_nil. reflexivity.
  - intros. destruct n.
    + exists (a :: l). simpl. reflexivity.
    + specialize (IHl n). destruct IHl as [suf H].
      simpl list_prefix.
      exists suf. simpl.
      rewrite <- H.
      reflexivity. 
Qed.

Lemma list_cons_app : forall l1 x, 
  exists (l2 : list Z) (a : Z), 
  x :: l1 = l2 ++ [a] /\ l2 = (list_prefix (x :: l1) (length l1))
    /\ Some a = list_index (x :: l1) (length l1).
Proof.   (* 3:[x,l1]=[l2,a] *)
  intros l1. induction l1; intros.
  - exists nil, x. auto.
  - specialize (IHl1 a).
    destruct IHl1 as [l2 [b H]].
    destruct H as [H [H1 H2]].
    exists (x :: l2), b.
    split.
    + rewrite H. reflexivity.
    + split.
      * simpl. rewrite <- H1. reflexivity.
      * rewrite H2. simpl. reflexivity.
Qed.

(* TODO: not sure whether useful *)
Lemma prefix_whole : forall l,    
  list_prefix l (length l) = l.  (* 4: pre(l,len(l))=l *)
Proof.
  intros. induction l.
  - apply nil_prefix_nil.
  - simpl. rewrite IHl. reflexivity.
Qed.  

Lemma list_nth_nil : forall n,      (* 5:[].split(n)=[],null,[] *)
  list_nth_out nil n = (nil, None, nil).
Proof.
  intros. induction n.
  - reflexivity.
  - simpl. exact IHn.
Qed.

Lemma list_nth_split : forall l n l1 x l2, 
  list_nth_out l n = (l1, x, l2) -> 
  l1 = list_prefix l n /\ x = list_index l n.
Proof.                      (* 6: l.split(n)= pre(l1,n),l1[n],l2 *)
  intros l. induction l; intros.
  - rewrite nil_prefix_nil. 
    rewrite list_nth_nil in H.
    inversion H; subst.
    split; simpl; reflexivity.
  - destruct n.
    + simpl in *. inversion H; subst; split; reflexivity.
    + simpl in *. 
      remember (list_nth_out l n) as res.
      destruct res as [[l3 y] l4].
      inversion H; subst.
      split.
      * f_equal. 
        apply IHl with (x:=x) (l2:=l2).
        auto.
      * symmetry in Heqres.
        apply IHl in Heqres.
        exact (proj2 Heqres).
Qed.

Lemma list_nth_tail : forall (l l1 l2: list Z) (x : option Z),
  list_nth_out l ((length l) - 1) = (l1, x, l2) ->
  l2 = nil.      (*  7: l.split(len(l)-1)= l1,l[len(l)-1],[] *)    
Proof.
  intros l.
  induction l; intros.
  - rewrite list_nth_nil in H. inversion H. reflexivity.
  - destruct l.
    + simpl in H. inversion H; subst; reflexivity.
    + simpl in H.
      remember (list_nth_out (z :: l) (Datatypes.length l)) as pr.
      destruct pr as [[l3 y] l4].
      inversion H; subst.
      simpl_length.
      symmetry in Heqpr.
      apply IHl in Heqpr.
      exact Heqpr.
Qed.

Lemma list_nth_combine : forall (l l1 l2: list Z) (n : nat) (x : Z), 
  list_nth_out l n = (l1, Some x, l2) -> l1 ++ [x] ++ l2 = l.
Proof.             (*  8: cancat(l.split(n))= l1+l[n]+l2=l *) 
  intros l.
  induction l; intros.
  - rewrite list_nth_nil in H. inversion H.
  - destruct n.
    + simpl in H. inversion H; subst.
      reflexivity.
    + simpl in H.
      remember (list_nth_out l n) as res.
      destruct res as [[l3 y] l4].
      inversion H; subst.
      symmetry in Heqres.
      apply IHl in Heqres.
      simpl in *. rewrite Heqres.
      reflexivity.
Qed.

(***********************************************************************
III.Memory representation of doubly link list
***********************************************************************)

Definition t_struct_node : type := Tstruct _node noattr.
Definition t_struct_list : type := Tstruct _list noattr.

(** Memory representation of a node struct. *)
Definition node_rep (v : Z) (prev next p : val) : mpred :=
  data_at Tsh t_struct_node 
    (Vint (Int.repr v), (prev, next)) p. 
(*1: node_rep(v,prev,next,p): *p=(v,(prev,next)) *)

(* TODO: not sure whether useful *)
Lemma node_rep_saturate_local:
  forall x prev next p, node_rep x prev next p |-- !! is_pointer_or_null p.
Proof.
  intros. unfold node_rep. entailer. 
Qed.

Hint Resolve node_rep_saturate_local: saturate_local.
 (* Add to the lib*)

Lemma node_rep_valid_pointer:
  forall x prev next p, node_rep x prev next p |-- valid_pointer p.
Proof.
  intros. unfold node_rep. entailer!.
Qed.

Hint Resolve node_rep_valid_pointer: valid_pointer.

(** Memory representation of a dlinklist. *)
Fixpoint list_1n_rep_aux (l : list Z) (head tail : val) (prev : val) : mpred :=
  match l with
  | x :: l'   => EX old_head : val,
    node_rep x prev old_head head * list_1n_rep_aux l' old_head tail head
  | nil       => !! (tail = prev /\ is_pointer_or_null head) && emp
  end.  (* 问题：tail=prev=null?  emp?*)

(*2: [x,l1]:  *head=(x,prev,old_head) /\ old_head->[]->[]->[] *)

(** Memory representation of a dlinklist. If l is empty then head will be NULL. *)
Fixpoint list_1n_rep (l : list Z) (head tail : val) (prev : val) : mpred :=
  match l with
  | x :: l'   => EX old_head : val,
    node_rep x prev old_head head * list_1n_rep l' old_head tail head
  | nil       => !! (tail = prev /\ head = nullval) && emp
  end.
 (* same as 2 *)

Lemma list_1n_rep_saturate_local_head:
  forall l head tail prev, list_1n_rep l head tail prev |-- 
    !! is_pointer_or_null head.
Proof.
  intros l. 
  destruct l; intros; simpl.
  - entailer!.
  - Intros old_head. entailer!.
Qed.

Hint Resolve list_1n_rep_saturate_local_head: saturate_local.

Lemma list_1n_rep_aux_saturate_local_head:
  forall l head tail prev, list_1n_rep_aux l head tail prev |-- 
    !! is_pointer_or_null head.
Proof.
  intros l. 
  destruct l; intros; simpl.
  - entailer!.
  - Intros old_head. entailer!.
Qed.

Hint Resolve list_1n_rep_aux_saturate_local_head: saturate_local.

Lemma list_1n_rep_valid_pointer_head:
  forall l head tail prev, list_1n_rep l head tail prev |-- 
    valid_pointer head.
Proof.
  intros l. 
  destruct l; intros; simpl.
  - entailer!.
  - Intros old_head. entailer!.
Qed.

Hint Resolve list_1n_rep_valid_pointer_head: valid_pointer.

Lemma list_1n_rep_saturate_local_tail:
  forall l head tail prev, 
    is_pointer_or_null prev -> list_1n_rep l head tail prev |-- 
    !! is_pointer_or_null tail.
Proof.
  intros l. 
  induction l; intros; simpl.
  - entailer!.
  - Intros old_head. 
    assert_PROP (is_pointer_or_null head) by entailer!. 
    sep_apply (IHl old_head tail head H0). 
    entailer!.
Qed.

Hint Resolve list_1n_rep_saturate_local_tail: saturate_local.
  (*Aboves are some not null proof *)


Definition Z_length (l : list Z) : Z := Z.of_nat (length l).

(** Memory representation of a list struct. *)
Definition list_rep (l : list Z) (p : val) : mpred :=
  EX head : val, EX tail : val,
  data_at Tsh t_struct_list 
      (Vint (Int.repr (Z_length l)), (head, tail)) p *
      list_1n_rep l head tail nullval.
 (* 3:list A= (head,tail, [x,l1]),*p=(head,tail,length) *)

Lemma list_rep_saturate_local:
  forall l p, list_rep l p |-- !! is_pointer_or_null p.
Proof.
  intros. destruct l; unfold list_rep; try Intros head tail; entailer!.
Qed.

Hint Resolve list_rep_saturate_local: saturate_local.

Lemma list_rep_valid_pointer:
  forall l p, list_rep l p |-- valid_pointer p.
Proof.
  intros. destruct l; unfold list_rep; simpl; try Intros head tail; entailer!.
Qed.

Hint Resolve list_rep_valid_pointer: valid_pointer.

(** A list can be split into two parts. This will be useful. *)
Theorem list_1n_split : forall l l1 l2,    
  l = l1 ++ l2 ->
  (forall head tail prev, 
  list_1n_rep l head tail prev |--
  EX head' : val, EX tail' : val,  
    list_1n_rep_aux l1 head tail' prev * list_1n_rep l2 head' tail tail').
Proof. (* 4: l=l1+l2:l= head->l1->tail',head'->l2->tail *)
  intros l l1.
  revert l.
  induction l1; intros; simpl in H.
  - subst.
    Exists head prev.
    simpl list_1n_rep_aux.
    entailer!. 
  - subst.
    simpl list_1n_rep at 1.
    Intros old_head.
    assert (l1 ++ l2 = l1 ++ l2) by reflexivity.
    specialize (IHl1 _ _ H).
    clear H.
    sep_apply IHl1.
    clear IHl1.
    Intros head' tail'.
    Exists head' tail'.
    simpl list_1n_rep_aux.
    Exists old_head.
    entailer!.
Qed.

(** An equivalent representation of dlinklist, but the (n+1)th element 
    is singled out. *)
Definition list_single_out (l : list Z) (n : nat) (p : val) : mpred :=
  match list_nth_out l n with
  | (l1, None, l2)    => !! (p = nullval)
  | (l1, Some x, l2)    => 
    EX head1 : val, EX tail1 : val, 
    EX head2 : val, EX tail2 : val,
      list_1n_rep_aux l1 head1 tail1 nullval * 
      node_rep x tail1 head2 p *
      list_1n_rep l2 head2 tail2 p
  end.
(* 命题： p是链表中的第n个节点 *)


(***********************************************************************
IV.Function specifications
***********************************************************************)

(* mallocN *)
Definition mallocN_spec :=
 DECLARE _mallocN
  WITH n: Z
  PRE [ 1%positive OF tint]
     PROP (4 <= n <= Int.max_unsigned)
     LOCAL (temp 1%positive (Vint (Int.repr n)))
     SEP ()
  POST [ tptr tvoid ]
     EX v: val,
     PROP (malloc_compatible n v)
     LOCAL (temp ret_temp v)
     SEP (memory_block Tsh n v).

(* freeN *)
Definition freeN_spec :=
 DECLARE _freeN
  WITH p : val , n : Z
  PRE [ 1%positive OF tptr tvoid , 2%positive OF tint]
      PROP() LOCAL (temp 1%positive p; temp 2%positive (Vint (Int.repr n)))
      SEP (memory_block Tsh n p)
  POST [ tvoid ]
    PROP () LOCAL () SEP ().

(* list_new *)
Definition list_new_spec :=
 DECLARE _list_new
  WITH u : unit
  PRE  [  ]
       PROP() LOCAL() SEP ()
  POST [ tptr t_struct_list ]
    EX v: val,
    PROP ()
    LOCAL (temp ret_temp v)
    SEP (list_rep nil v).

(* list_free *)
Definition list_free_spec :=
 DECLARE _list_free
  WITH p : val, l : list Z
  PRE  [ _l OF (tptr t_struct_list) ]
    PROP () 
    LOCAL (temp _l p) 
    SEP (list_rep l p)
  POST [ Tvoid ]
    PROP ()
    LOCAL ()
    SEP (emp).

(* begin *)
Definition begin_spec :=
 DECLARE _begin
  WITH p : val, l : list Z
  PRE  [ _l OF (tptr t_struct_list) ]
    PROP () 
    LOCAL (temp _l p) 
    SEP (list_rep l p)
  POST [ tptr t_struct_node ]
    EX res : val, EX head : val, EX tail : val, 
    PROP ()
    LOCAL (temp ret_temp res)
    SEP (data_at Tsh t_struct_list
          (Vint (Int.repr (Z_length l)), (head, tail)) p; 
          list_single_out l 0%nat res).

(* end *)
Definition end_spec :=
 DECLARE _end
  WITH p : val, l : list Z
  PRE  [ _l OF (tptr t_struct_list) ]
    PROP () 
    LOCAL (temp _l p) 
    SEP (list_rep l p)
  POST [ tptr t_struct_node ]
    EX res : val, EX head : val, EX tail : val, 
    PROP ()
    LOCAL (temp ret_temp res)
    SEP (data_at Tsh t_struct_list
          (Vint (Int.repr (Z_length l)), (head, tail)) p; 
          list_single_out l ((length l) - 1)%nat res).

(* rbegin *)
Definition rbegin_spec :=
 DECLARE _rbegin
  WITH p : val, l : list Z
  PRE  [ _l OF (tptr t_struct_list) ]
    PROP () 
    LOCAL (temp _l p) 
    SEP (list_rep l p)
  POST [ tptr t_struct_node ]
    EX res : val, EX head : val, EX tail : val, 
    PROP ()
    LOCAL (temp ret_temp res)
    SEP (data_at Tsh t_struct_list
          (Vint (Int.repr (Z_length l)), (head, tail)) p; 
          list_single_out l ((length l) - 1)%nat res).

(* rend *)
Definition rend_spec :=
 DECLARE _rend
  WITH p : val, l : list Z
  PRE  [ _l OF (tptr t_struct_list) ]
    PROP () 
    LOCAL (temp _l p) 
    SEP (list_rep l p)
  POST [ tptr t_struct_node ]
    EX res : val, EX head : val, EX tail : val, 
    PROP ()
    LOCAL (temp ret_temp res)
    SEP (data_at Tsh t_struct_list
          (Vint (Int.repr (Z_length l)), (head, tail)) p; 
          list_single_out l 0%nat res).

(* get_size *)
Definition get_size_spec :=
 DECLARE _get_size
  WITH p : val, l : list Z
  PRE  [ _l OF (tptr t_struct_list) ]
    PROP () 
    LOCAL (temp _l p) 
    SEP (list_rep l p)
  POST [ tuint ]
    PROP ()
    LOCAL (temp ret_temp (Vint (Int.repr (Z_length l))))
    SEP (list_rep l p).

(* next *)
Definition next_spec :=
 DECLARE _next
  WITH p : val, x : Z, prev : val, next : val
  PRE  [ _p OF (tptr t_struct_node) ]
    PROP () 
    (* 是否应该用 is_pointer_or_null 解决？ *)
    LOCAL (temp _p p) 
    SEP (node_rep x prev next p)
  POST [ tptr t_struct_node ]
    PROP ()
    LOCAL (temp ret_temp next)
    SEP (node_rep x prev next p).

(* rnext *)
Definition rnext_spec :=
 DECLARE _rnext
  WITH p : val, x : Z, prev : val, next : val
  PRE  [ _p OF (tptr t_struct_node) ]
    PROP () 
    LOCAL (temp _p p) 
    SEP (node_rep x prev next p)
  POST [ tptr t_struct_node ]
    PROP ()
    LOCAL (temp ret_temp prev)
    SEP (node_rep x prev next p).

(* push_back *)
Definition push_back_spec :=
 DECLARE _push_back
  WITH p : val, l : list Z, v : Z
  PRE  [ _l OF (tptr t_struct_list), _v OF tuint ]
    PROP () 
    LOCAL (temp _l p; temp _v (Vint (Int.repr v))) 
    SEP (list_rep l p)
  POST [ Tvoid ]
    PROP ()
    LOCAL ()
    SEP (list_rep (l ++ [v]) p).

(* push_front *)
Definition push_front_spec :=
 DECLARE _push_front
  WITH p : val, l : list Z, v : Z
  PRE  [ _l OF (tptr t_struct_list), _v OF tuint ]
    PROP () 
    LOCAL (temp _l p; temp _v (Vint (Int.repr v))) 
    SEP (list_rep l p)
  POST [ Tvoid ]
    PROP ()
    LOCAL ()
    SEP (list_rep (v :: l) p).

(** All functions of the program. *)
Definition Gprog : funspecs :=
  ltac:(with_library prog [
    mallocN_spec;           (* vacuous truth! *)
    freeN_spec;             (* vacuous truth! *)
    list_new_spec;          (* OK! *)
    list_free_spec;         (* OK! *)
    begin_spec;             (* OK! *)
    end_spec;               (* OK! *)
    rbegin_spec;            (* OK! *)
    rend_spec;              (* OK! *)
    next_spec;
    rnext_spec;
    get_size_spec           (* OK! *)
    (* push_back_spec *)
    (* pop_back_spec *)     (* zjl *)
    (* push_front_spec *)
    (* pop_front_spec *)     (* lmn *)
    (* move_spec *)
    (* insert_spec *)
    (* delete_spec *)
    (* merge_spec *)
    (* split_K_spec *)     (* zqy *)
  ]).

